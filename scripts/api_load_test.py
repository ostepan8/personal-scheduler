#!/usr/bin/env python3
"""
API Load Testing Script for Scheduler System

This script performs load testing on the running API server,
measuring throughput, latency, and error rates.
"""

import time
import json
import argparse
import statistics
import concurrent.futures
from datetime import datetime, timedelta
from typing import Dict, List, Any
import requests
from dataclasses import dataclass
import threading

@dataclass
class TestResult:
    status_code: int
    response_time: float
    error: str = None
    
class APILoadTester:
    def __init__(self, base_url: str = "http://localhost:8080"):
        self.base_url = base_url
        self.session = requests.Session()
        self.results: List[TestResult] = []
        self.lock = threading.Lock()
        
    def test_get_events(self) -> TestResult:
        """Test GET /events endpoint."""
        start_time = time.time()
        try:
            response = self.session.get(f"{self.base_url}/events")
            response_time = time.time() - start_time
            return TestResult(
                status_code=response.status_code,
                response_time=response_time * 1000  # Convert to milliseconds
            )
        except Exception as e:
            response_time = time.time() - start_time
            return TestResult(
                status_code=0,
                response_time=response_time * 1000,
                error=str(e)
            )
    
    def test_create_event(self, event_id: str) -> TestResult:
        """Test POST /events endpoint."""
        event_data = {
            "title": f"Load Test Event {event_id}",
            "description": "Generated by load test",
            "time": (datetime.now() + timedelta(hours=1)).strftime("%Y-%m-%d %H:%M"),
            "duration": 60,
            "category": "Load Test"
        }
        
        start_time = time.time()
        try:
            response = self.session.post(
                f"{self.base_url}/events",
                json=event_data,
                headers={"Content-Type": "application/json"}
            )
            response_time = time.time() - start_time
            return TestResult(
                status_code=response.status_code,
                response_time=response_time * 1000
            )
        except Exception as e:
            response_time = time.time() - start_time
            return TestResult(
                status_code=0,
                response_time=response_time * 1000,
                error=str(e)
            )
    
    def test_get_stats(self) -> TestResult:
        """Test GET /stats endpoint."""
        today = datetime.now().strftime("%Y-%m-%d")
        tomorrow = (datetime.now() + timedelta(days=1)).strftime("%Y-%m-%d")
        
        start_time = time.time()
        try:
            response = self.session.get(f"{self.base_url}/stats/events/{today}/{tomorrow}")
            response_time = time.time() - start_time
            return TestResult(
                status_code=response.status_code,
                response_time=response_time * 1000
            )
        except Exception as e:
            response_time = time.time() - start_time
            return TestResult(
                status_code=0,
                response_time=response_time * 1000,
                error=str(e)
            )
    
    def worker_thread(self, test_function, iterations: int, thread_id: int):
        """Worker thread for concurrent testing."""
        for i in range(iterations):
            if test_function == 'create':
                result = self.test_create_event(f"{thread_id}_{i}")
            elif test_function == 'stats':
                result = self.test_get_stats()
            else:  # default to get_events
                result = self.test_get_events()
            
            with self.lock:
                self.results.append(result)
    
    def run_load_test(self, test_type: str, total_requests: int, 
                     concurrent_threads: int = 10, duration: int = None) -> Dict[str, Any]:
        """Run load test with specified parameters."""
        print(f"üöÄ Starting {test_type} load test...")
        print(f"   Total requests: {total_requests}")
        print(f"   Concurrent threads: {concurrent_threads}")
        if duration:
            print(f"   Duration: {duration} seconds")
        print(f"   Target: {self.base_url}")
        print()
        
        # Clear previous results
        self.results.clear()
        
        # Test connectivity first
        try:
            response = self.session.get(f"{self.base_url}/events")
            if response.status_code >= 400:
                print(f"‚ùå Server connectivity test failed: {response.status_code}")
                return {}
        except Exception as e:
            print(f"‚ùå Cannot connect to server: {e}")
            return {}
        
        start_time = time.time()
        requests_per_thread = total_requests // concurrent_threads
        
        # Launch threads
        with concurrent.futures.ThreadPoolExecutor(max_workers=concurrent_threads) as executor:
            futures = []
            for i in range(concurrent_threads):
                future = executor.submit(
                    self.worker_thread, 
                    test_type, 
                    requests_per_thread, 
                    i
                )
                futures.append(future)
            
            # Wait for completion or timeout
            if duration:
                time.sleep(duration)
                # Cancel remaining futures
                for future in futures:
                    future.cancel()
            else:
                concurrent.futures.wait(futures)
        
        total_time = time.time() - start_time
        
        return self._analyze_results(total_time)
    
    def _analyze_results(self, total_time: float) -> Dict[str, Any]:
        """Analyze load test results."""
        if not self.results:
            return {"error": "No results collected"}
        
        # Extract metrics
        response_times = [r.response_time for r in self.results]
        status_codes = [r.status_code for r in self.results]
        errors = [r for r in self.results if r.error or r.status_code >= 400]
        
        # Calculate statistics
        analysis = {
            'total_requests': len(self.results),
            'total_time': total_time,
            'requests_per_second': len(self.results) / total_time,
            'avg_response_time': statistics.mean(response_times),
            'min_response_time': min(response_times),
            'max_response_time': max(response_times),
            'median_response_time': statistics.median(response_times),
            'error_count': len(errors),
            'error_rate': len(errors) / len(self.results) * 100,
            'success_rate': (len(self.results) - len(errors)) / len(self.results) * 100
        }
        
        # Percentiles
        if len(response_times) >= 10:
            sorted_times = sorted(response_times)
            analysis['p95_response_time'] = sorted_times[int(0.95 * len(sorted_times))]
            analysis['p99_response_time'] = sorted_times[int(0.99 * len(sorted_times))]
        
        # Status code breakdown
        status_breakdown = {}
        for code in status_codes:
            status_breakdown[code] = status_breakdown.get(code, 0) + 1
        analysis['status_codes'] = status_breakdown
        
        # Error details
        if errors:
            error_types = {}
            for error in errors:
                if error.error:
                    error_types[error.error] = error_types.get(error.error, 0) + 1
                else:
                    error_types[f"HTTP {error.status_code}"] = error_types.get(f"HTTP {error.status_code}", 0) + 1
            analysis['error_types'] = error_types
        
        return analysis
    
    def print_results(self, analysis: Dict[str, Any]):
        """Print formatted load test results."""
        if 'error' in analysis:
            print(f"‚ùå {analysis['error']}")
            return
        
        print("=" * 60)
        print("             LOAD TEST RESULTS")
        print("=" * 60)
        print(f"Total Requests:      {analysis['total_requests']}")
        print(f"Total Time:          {analysis['total_time']:.2f} seconds")
        print(f"Requests/Second:     {analysis['requests_per_second']:.2f}")
        print()
        print("Response Times (ms):")
        print(f"  Average:           {analysis['avg_response_time']:.2f}")
        print(f"  Minimum:           {analysis['min_response_time']:.2f}")
        print(f"  Maximum:           {analysis['max_response_time']:.2f}")
        print(f"  Median:            {analysis['median_response_time']:.2f}")
        
        if 'p95_response_time' in analysis:
            print(f"  95th Percentile:   {analysis['p95_response_time']:.2f}")
            print(f"  99th Percentile:   {analysis['p99_response_time']:.2f}")
        
        print()
        print(f"Success Rate:        {analysis['success_rate']:.1f}%")
        print(f"Error Rate:          {analysis['error_rate']:.1f}%")
        print(f"Error Count:         {analysis['error_count']}")
        
        print("\nStatus Code Breakdown:")
        for code, count in analysis.get('status_codes', {}).items():
            status_emoji = "‚úÖ" if code < 300 else "‚ö†Ô∏è" if code < 400 else "‚ùå"
            print(f"  {status_emoji} {code}: {count}")
        
        if 'error_types' in analysis and analysis['error_types']:
            print("\nError Types:")
            for error_type, count in analysis['error_types'].items():
                print(f"  ‚ùå {error_type}: {count}")
        
        print("=" * 60)
    
    def save_results(self, analysis: Dict[str, Any], filename: str):
        """Save results to JSON file."""
        with open(filename, 'w') as f:
            json.dump({
                'timestamp': datetime.now().isoformat(),
                'analysis': analysis
            }, f, indent=2)
        print(f"üíæ Results saved to {filename}")

def main():
    parser = argparse.ArgumentParser(description='API Load Tester for Scheduler')
    parser.add_argument('--url', default='http://localhost:8080',
                       help='Base URL of the API server')
    parser.add_argument('--test-type', choices=['get', 'create', 'stats'], 
                       default='get', help='Type of test to run')
    parser.add_argument('--requests', type=int, default=100,
                       help='Total number of requests')
    parser.add_argument('--threads', type=int, default=10,
                       help='Number of concurrent threads')
    parser.add_argument('--duration', type=int,
                       help='Duration in seconds (overrides --requests)')
    parser.add_argument('--save', help='Save results to JSON file')
    
    args = parser.parse_args()
    
    tester = APILoadTester(args.url)
    
    analysis = tester.run_load_test(
        test_type=args.test_type,
        total_requests=args.requests,
        concurrent_threads=args.threads,
        duration=args.duration
    )
    
    if analysis:
        tester.print_results(analysis)
        
        if args.save:
            tester.save_results(analysis, args.save)
    
    print("\nüí° Tip: Try different test types with --test-type (get|create|stats)")
    print("üí° Tip: Increase load with --requests 1000 --threads 20")

if __name__ == '__main__':
    main()